<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title> üìö CLONE, Manual </title>
    <link href="./index.css" rel="stylesheet">
</head>

<body>
    <header class="nav-header">
        <a href="./index.html" class="home-button">üè† Home</a>
    </header>
    <article>
        <div><h1>üìö CLONE, Manual</h1><blockquote>*Beautiful, readable documentation for command-line tools*</blockquote><hr></hr><p>[<a href="./clone.html">clone(2)</a>](clone.html)                                                                                    System Calls Manual                                                                                    [<a href="./clone.html">clone(2)</a>](clone.html)</p><h2>üìë Table of Contents</h2><p>- <a href="#name">Name</a>   - <a href="#library">Library</a> - <a href="#synopsis">Synopsis</a> - <a href="#description">Description</a>   - <a href="#return-value">Return Value</a>   - <a href="#errors">Errors</a>   - <a href="#standards">Standards</a>   - <a href="#history">History</a> - <a href="#examples">Examples</a> - <a href="#see-also">See Also</a> - <a href="#name">Name</a>   - <a href="#library">Library</a> - <a href="#synopsis">Synopsis</a> - <a href="#description">Description</a>   - <a href="#return-value">Return Value</a>   - <a href="#errors">Errors</a>   - <a href="#standards">Standards</a>   - <a href="#history">History</a>   - <a href="#notes">Notes</a>   - <a href="#bugs">Bugs</a> - <a href="#see-also">See Also</a> - <a href="#name">Name</a>   - <a href="#library">Library</a> - <a href="#synopsis">Synopsis</a> - <a href="#description">Description</a>   - <a href="#return-value">Return Value</a>   - <a href="#errors">Errors</a>   - <a href="#versions">Versions</a>   - <a href="#standards">Standards</a>   - <a href="#history">History</a>   - <a href="#notes">Notes</a>   - <a href="#bugs">Bugs</a> - <a href="#see-also">See Also</a> - <a href="#name">Name</a> - <a href="#synopsis">Synopsis</a> - <a href="#description">Description</a>   - <a href="#bugs">Bugs</a>   - <a href="#author">Author</a>   - <a href="#reporting-bugs">Reporting Bugs</a>   - <a href="#copyright">Copyright</a> - <a href="#see-also">See Also</a> - <a href="#name">Name</a>   - <a href="#library">Library</a> - <a href="#synopsis">Synopsis</a> - <a href="#description">Description</a>   - <a href="#return-value">Return Value</a>   - <a href="#errors">Errors</a>   - <a href="#attributes">Attributes</a>   - <a href="#standards">Standards</a>   - <a href="#posix.1-2008.">Posix.1-2008.</a>   - <a href="#history">History</a>   - <a href="#notes">Notes</a> - <a href="#see-also">See Also</a> - <a href="#name">Name</a>   - <a href="#library">Library</a> - <a href="#synopsis">Synopsis</a> - <a href="#description">Description</a>   - <a href="#return-value">Return Value</a>   - <a href="#errors">Errors</a>   - <a href="#standards">Standards</a>   - <a href="#posix.1-2008.">Posix.1-2008.</a>   - <a href="#history">History</a>   - <a href="#posix.1-2001.">Posix.1-2001.</a>   - <a href="#notes">Notes</a>   - <a href="#bugs">Bugs</a> - <a href="#see-also">See Also</a> - <a href="#name">Name</a> - <a href="#synopsis">Synopsis</a> - <a href="#description">Description</a>   - <a href="#author">Author</a>   - <a href="#reporting-bugs">Reporting Bugs</a>   - <a href="#copyright">Copyright</a> - <a href="#see-also">See Also</a> - <a href="#name">Name</a> - <a href="#synopsis">Synopsis</a> - <a href="#description">Description</a>   - <a href="#author">Author</a>   - <a href="#reporting-bugs">Reporting Bugs</a>   - <a href="#copyright">Copyright</a> - <a href="#see-also">See Also</a> - <a href="#name">Name</a> - <a href="#synopsis">Synopsis</a> - <a href="#description">Description</a> - <a href="#options">Options</a> - <a href="#authors">Authors</a> - <a href="#see-also">See Also</a>   - <a href="#reporting-bugs">Reporting Bugs</a>   - <a href="#availability">Availability</a> - <a href="#name">Name</a> - <a href="#synopsis">Synopsis</a> - <a href="#description">Description</a>   - <a href="#author">Author</a>   - <a href="#reporting-bugs">Reporting Bugs</a>   - <a href="#copyright">Copyright</a> - <a href="#see-also">See Also</a> - <a href="#name">Name</a>   - <a href="#library">Library</a> - <a href="#synopsis">Synopsis</a> - <a href="#description">Description</a>   - <a href="#return-value">Return Value</a>   - <a href="#errors">Errors</a>   - <a href="#standards">Standards</a>   - <a href="#posix.1-2008.">Posix.1-2008.</a>   - <a href="#history">History</a>   - <a href="#notes">Notes</a>   - <a href="#bugs">Bugs</a> - <a href="#see-also">See Also</a> - <a href="#name">Name</a>   - <a href="#library">Library</a> - <a href="#synopsis">Synopsis</a> - <a href="#description">Description</a>   - <a href="#return-value">Return Value</a>   - <a href="#errors">Errors</a>   - <a href="#standards">Standards</a>   - <a href="#history">History</a>   - <a href="#notes">Notes</a>   - <a href="#bugs">Bugs</a> - <a href="#see-also">See Also</a> - <a href="#name">Name</a>   - <a href="#library">Library</a> - <a href="#synopsis">Synopsis</a> - <a href="#description">Description</a>   - <a href="#return-value">Return Value</a>   - <a href="#errors">Errors</a> - <a href="#files">Files</a>   - <a href="#attributes">Attributes</a>   - <a href="#standards">Standards</a>   - <a href="#history">History</a> - <a href="#see-also">See Also</a> - <a href="#name">Name</a>   - <a href="#library">Library</a> - <a href="#synopsis">Synopsis</a> - <a href="#description">Description</a>   - <a href="#return-value">Return Value</a>   - <a href="#errors">Errors</a>   - <a href="#standards">Standards</a>   - <a href="#history">History</a>   - <a href="#notes">Notes</a>   - <a href="#bugs">Bugs</a> - <a href="#see-also">See Also</a> - <a href="#name">Name</a> - <a href="#synopsis">Synopsis</a>   - <a href="#target">Target</a> - <a href="#description">Description</a> - <a href="#options">Options</a> - <a href="#see-also">See Also</a>   - <a href="#copyright">Copyright</a> - <a href="#name">Name</a> - <a href="#synopsis">Synopsis</a> - <a href="#description">Description</a>   - <a href="#author">Author</a>   - <a href="#reporting-bugs">Reporting Bugs</a>   - <a href="#copyright">Copyright</a> - <a href="#see-also">See Also</a> - <a href="#name">Name</a> - <a href="#synopsis">Synopsis</a> - <a href="#description">Description</a> - <a href="#environment">Environment</a> - <a href="#files">Files</a> - <a href="#see-also">See Also</a> - <a href="#authors">Authors</a> - <a href="#name">Name</a> - <a href="#synopsis">Synopsis</a> - <a href="#description">Description</a>   - <a href="#exit-status">Exit Status</a> - <a href="#environment">Environment</a> - <a href="#files">Files</a> - <a href="#see-also">See Also</a>   - <a href="#history">History</a>   - <a href="#bugs">Bugs</a> - <a href="#name">Name</a>   - <a href="#library">Library</a> - <a href="#synopsis">Synopsis</a> - <a href="#description">Description</a>   - <a href="#return-value">Return Value</a>   - <a href="#attributes">Attributes</a>   - <a href="#standards">Standards</a>   - <a href="#c11,-posix.1-2008.">C11, Posix.1-2008.</a>   - <a href="#history">History</a> - <a href="#see-also">See Also</a> - <a href="#name">Name</a>   - <a href="#library">Library</a> - <a href="#synopsis">Synopsis</a> - <a href="#description">Description</a>   - <a href="#seccomp_ret_errno">Seccomp_Ret_Errno</a>   - <a href="#return-value">Return Value</a>   - <a href="#errors">Errors</a>   - <a href="#standards">Standards</a>   - <a href="#history">History</a>   - <a href="#notes">Notes</a> - <a href="#examples">Examples</a> - <a href="#see-also">See Also</a> - <a href="#name">Name</a>   - <a href="#library">Library</a> - <a href="#synopsis">Synopsis</a> - <a href="#description">Description</a>   - <a href="#return-value">Return Value</a>   - <a href="#errors">Errors</a>   - <a href="#standards">Standards</a>   - <a href="#posix.1-2008.">Posix.1-2008.</a>   - <a href="#history">History</a>   - <a href="#posix.1-2001.">Posix.1-2001.</a> - <a href="#see-also">See Also</a> - <a href="#name">Name</a>   - <a href="#library">Library</a> - <a href="#synopsis">Synopsis</a> - <a href="#description">Description</a>   - <a href="#return-value">Return Value</a>   - <a href="#errors">Errors</a>   - <a href="#versions">Versions</a>   - <a href="#standards">Standards</a>   - <a href="#posix.1-2008.">Posix.1-2008.</a>   - <a href="#history">History</a>   - <a href="#notes">Notes</a>   - <a href="#bugs">Bugs</a> - <a href="#examples">Examples</a> - <a href="#see-also">See Also</a> - <a href="#name">Name</a> - <a href="#synopsis">Synopsis</a> - <a href="#description">Description</a>   - <a href="#arguments">Arguments</a> - <a href="#options">Options</a> - <a href="#see-also">See Also</a>   - <a href="#url">Url</a> - <a href="#authors">Authors</a> - <a href="#name">Name</a>   - <a href="#library">Library</a> - <a href="#synopsis">Synopsis</a> - <a href="#description">Description</a>   - <a href="#return-value">Return Value</a>   - <a href="#errors">Errors</a>   - <a href="#standards">Standards</a>   - <a href="#notes">Notes</a> - <a href="#see-also">See Also</a> - <a href="#name">Name</a> - <a href="#synopsis">Synopsis</a> - <a href="#description">Description</a> - <a href="#options">Options</a>   - <a href="#exit-status">Exit Status</a> - <a href="#environment">Environment</a> - <a href="#files">Files</a>   - <a href="#notes">Notes</a>   - <a href="#nfs">Nfs</a>   - <a href="#history">History</a> - <a href="#see-also">See Also</a>   - <a href="#reporting-bugs">Reporting Bugs</a>   - <a href="#availability">Availability</a> - <a href="#name">Name</a>   - <a href="#library">Library</a> - <a href="#synopsis">Synopsis</a> - <a href="#description">Description</a>   - <a href="#return-value">Return Value</a>   - <a href="#errors">Errors</a>   - <a href="#versions">Versions</a>   - <a href="#standards">Standards</a>   - <a href="#history">History</a>   - <a href="#notes">Notes</a>   - <a href="#bugs">Bugs</a> - <a href="#examples">Examples</a> - <a href="#see-also">See Also</a></p><h2 id="name">Name</h2><pre><code>clone, __clone2, clone3 - create a child process
</code></pre><h3 id="library">Library</h3><pre><code>Standard C library (libc, -lc)
</code></pre><h2 id="synopsis">Synopsis</h2><p>` /* Prototype for the glibc wrapper function */</p><p>#define _GNU_SOURCE #include <sched.h></p><p>int clone(int (*fn)(void *_Nullable), void *stack, int flags,           void *_Nullable arg, ...  /* pid_t *_Nullable parent_tid,                                        void *_Nullable tls,                                        pid_t *_Nullable child_tid */ );</p><p>/* For the prototype of the raw clone() system call, see NOTES */</p><p>#include <linux/sched.h>    /* Definition of struct clone_args */ #include <sched.h>          /* Definition of CLONE_* constants */ #include <sys/syscall.h>    /* Definition of SYS_* constants */ #include <unistd.h></p><p>long syscall(SYS_clone3, struct clone_args *cl_args, size_t size);</p><p>Note: glibc provides no wrapper for clone3(), necessitating the use of <a href="./syscall.html">syscall(2)</a>. `</p><h2 id="description">Description</h2><p>` These system calls create a new ("child") process, in a manner similar to <a href="./fork.html">fork(2)</a>.</p><p>By  contrast  with  <a href="./fork.html">fork(2)</a>, these system calls provide more precise control over what pieces of execution context are shared between the calling process and the child process.  For example, using these system calls, the caller can control whether or not the two processes share the virtual address space, the table of file descriptors, and the table of signal handlers.   These  system  calls also allow the new child process to be placed in separate <a href="./namespaces.html">namespaces(7)</a>.</p><p>Note that in this manual page, "calling process" normally corresponds to "parent process".  But see the descriptions of CLONE_PARENT and CLONE_THREAD below.</p><p>This page describes the following interfaces: `</p><p>‚Ä¢  The  glibc clone() wrapper function and the underlying system call on which it is based.  The main text describes the wrapper function; the differences for the raw system call are described to‚Äê           ward the end of this page.</p><p>‚Ä¢  The newer clone3() system call.</p><pre><code>In the remainder of this page, the terminology "the clone call" is used when noting details that apply to all of these interfaces.
</code></pre><p>The clone() wrapper function ` When the child process is created with the clone() wrapper function, it commences execution by calling the function pointed to by the argument fn.  (This differs from <a href="./fork.html">fork(2)</a>, where execution con‚Äê tinues in the child from the point of the <a href="./fork.html">fork(2)</a> call.)  The arg argument is passed as the argument of the function fn.</p><p>When the fn(arg) function returns, the child process terminates.  The integer returned by fn is the exit status for the child process.  The child process may also terminate explicitly  by  calling <a href="./exit.html">exit(2)</a> or after receiving a fatal signal.</p><p>The  stack argument specifies the location of the stack used by the child process.  Since the child and calling process may share memory, it is not possible for the child process to execute in the same stack as the calling process.  The calling process must therefore set up memory space for the child stack and pass a pointer to this space to clone().  Stacks grow downward on all  processors that run Linux (except the HP PA processors), so stack usually points to the topmost address of the memory space set up for the child stack.  Note that clone() does not provide a means whereby the caller can inform the kernel of the size of the stack area.</p><p>The remaining arguments to clone() are discussed below. `</p><p>clone3() ` The  clone3()  system  call  provides  a  superset  of the functionality of the older clone() interface.  It also provides a number of API improvements, including: space for additional flags bits; cleaner separation in the use of various arguments; and the ability to specify the size of the child's stack area.</p><p>As with <a href="./fork.html">fork(2)</a>, clone3() returns in both the parent and the child.  It returns 0 in the child process and returns the PID of the child in the parent.</p><p>The cl_args argument of clone3() is a structure of the following form:</p><p>struct clone_args {         u64 flags;        /* Flags bit mask */         u64 pidfd;        /* Where to store PID file descriptor                              (int *) */         u64 child_tid;    /* Where to store child TID,                              in child's memory (pid_t *) */         u64 parent_tid;   /* Where to store child TID,                              in parent's memory (pid_t *) */         u64 exit_signal;  /* Signal to deliver to parent on                              child termination */         u64 stack;        /* Pointer to lowest byte of stack */         u64 stack_size;   /* Size of stack */         u64 tls;          /* Location of new TLS */         u64 set_tid;      /* Pointer to a pid_t array                              (since Linux 5.5) */         u64 set_tid_size; /* Number of elements in set_tid                              (since Linux 5.5) */         u64 cgroup;       /* File descriptor for target cgroup                              of child (since Linux 5.7) */     };</p><p>The size argument that is supplied to clone3() should be initialized to the size of this structure.  (The existence of the size argument permits future extensions to the clone_args structure.)</p><p>The stack for the child process is specified via cl_args.stack, which points to the lowest byte of the stack area, and cl_args.stack_size, which specifies the size of the stack in bytes.   In  the case  where  the  CLONE_VM flag (see below) is specified, a stack must be explicitly allocated and specified.  Otherwise, these two fields can be specified as NULL and 0, which causes the child to use the same stack area as the parent (in the child's own virtual address space).</p><p>The remaining fields in the cl_args argument are discussed below. `</p><p>Equivalence between clone() and clone3() arguments ` Unlike the older clone() interface, where arguments are passed individually, in the newer clone3() interface the arguments are packaged into the clone_args structure shown above.   This  structure allows for a superset of the information passed via the clone() arguments.</p><p>The following table shows the equivalence between the arguments of clone() and the fields in the clone_args argument supplied to clone3():     clone()         clone3()        Notes                     cl_args field     flags & ~0xff   flags           For most flags; details below     parent_tid      pidfd           See CLONE_PIDFD     child_tid       child_tid       See CLONE_CHILD_SETTID     parent_tid      parent_tid      See CLONE_PARENT_SETTID     flags & 0xff    exit_signal     stack           stack     ---             stack_size     tls             tls             See CLONE_SETTLS     ---             set_tid         See below for details     ---             set_tid_size     ---             cgroup          See CLONE_INTO_CGROUP `</p><p>The child termination signal <code> When the child process terminates, a signal may be sent to the parent.  The termination signal is specified in the low byte of flags (clone()) or in cl_args.exit_signal (clone3()).  If this signal is  specified  as anything other than SIGCHLD, then the parent process must specify the __WALL or __WCLONE options when waiting for the child with [wait(2)](./wait.html).  If no signal (i.e., zero) is specified, then the parent process is not signaled when the child terminates. </code></p><p>The set_tid array ` By default, the kernel chooses the next sequential PID for the new process in each of the PID namespaces where it is present.  When creating a process with clone3(), the set_tid  array  (available since  Linux  5.5) can be used to select specific PIDs for the process in some or all of the PID namespaces where it is present.  If the PID of the newly created process should be set only for the current PID namespace or in the newly created PID namespace (if flags contains CLONE_NEWPID) then the first element in the set_tid array has to be the desired PID and set_tid_size needs to be 1.</p><p>If the PID of the newly created process should have a certain value in multiple PID namespaces, then the set_tid array can have multiple entries.  The first entry  defines  the  PID  in  the  most deeply nested PID namespace and each of the following entries contains the PID in the corresponding ancestor PID namespace.  The number of PID namespaces in which a PID should be set is defined by set_tid_size which cannot be larger than the number of currently nested PID namespaces.</p><p>To create a process with the following PIDs in a PID namespace hierarchy:     PID NS level   Requested PID   Notes     0              31496           Outermost PID namespace     1              42     2              7               Innermost PID namespace</p><p>Set the array to:</p><p>set_tid[0] = 7;     set_tid[1] = 42;     set_tid[2] = 31496;     set_tid_size = 3;</p><p>If only the PIDs in the two innermost PID namespaces need to be specified, set the array to:</p><p>set_tid[0] = 7;     set_tid[1] = 42;     set_tid_size = 2;</p><p>The PID in the PID namespaces outside the two innermost PID namespaces is selected the same way as any other PID is selected.</p><p>The set_tid feature requires CAP_SYS_ADMIN or (since Linux 5.9) CAP_CHECKPOINT_RESTORE in all owning user namespaces of the target PID namespaces.</p><p>Callers  may only choose a PID greater than 1 in a given PID namespace if an init process (i.e., a process with PID 1) already exists in that namespace.  Otherwise the PID entry for this PID name‚Äê space must be 1. `</p><p>The flags mask ` Both clone() and clone3() allow a flags bit mask that modifies their behavior and allows the caller to specify what is shared between the calling process and the child process.  This bit  mask‚Äîthe flags argument of clone() or the cl_args.flags field passed to clone3()‚Äîis referred to as the flags mask in the remainder of this page.</p><p>The  flags  mask  is  specified  as  a  bitwise  OR  of zero or more of the constants listed below.  Except as noted below, these flags are available (and have the same effect) in both clone() and clone3().</p><p>CLONE_CHILD_CLEARTID (since Linux 2.5.49)        Clear (zero) the child thread ID at the location pointed to by child_tid (clone()) or cl_args.child_tid (clone3()) in child memory when the child exits, and do a wakeup on the futex at that        address.  The address involved may be changed by the <a href="./set_tid_address.html">set_tid_address(2)</a> system call.  This is used by threading libraries.</p><p>CLONE_CHILD_SETTID (since Linux 2.5.49)        Store the child thread ID at the location pointed to by child_tid (clone()) or cl_args.child_tid (clone3()) in the child's memory.  The store operation completes before the clone  call  re‚Äê        turns  control  to  user  space  in  the  child process.  (Note that the store operation may not have completed before the clone call returns in the parent process, which is relevant if the        CLONE_VM flag is also employed.)</p><p>CLONE_CLEAR_SIGHAND (since Linux 5.5)        By default, signal dispositions in the child thread are the same as in the parent.  If this flag is specified, then all signals that are handled in the parent (and not set to  SIG_IGN)  are        reset to their default dispositions (SIG_DFL) in the child.</p><p>Specifying this flag together with CLONE_SIGHAND is nonsensical and disallowed.</p><p>CLONE_DETACHED (historical)        For  a while (during the Linux 2.5 development series) there was a CLONE_DETACHED flag, which caused the parent not to receive a signal when the child terminated.  Ultimately, the effect of        this flag was subsumed under the CLONE_THREAD flag and by the time Linux 2.6.0 was released, this flag had no effect.  Starting in Linux 2.6.2, the need to  give  this  flag  together  with        CLONE_THREAD disappeared.</p><p>This flag is still defined, but it is usually ignored when calling clone().  However, see the description of CLONE_PIDFD for some exceptions.</p><p>CLONE_FILES (since Linux 2.0)        If  CLONE_FILES  is  set, the calling process and the child process share the same file descriptor table.  Any file descriptor created by the calling process or by the child process is also        valid in the other process.  Similarly, if one of the processes closes a file descriptor, or changes its associated flags (using the <a href="./fcntl.html">fcntl(2)</a> F_SETFD operation), the other process  is  also        affected.  If a process sharing a file descriptor table calls <a href="./execve.html">execve(2)</a>, its file descriptor table is duplicated (unshared).</p><p>If  CLONE_FILES  is not set, the child process inherits a copy of all file descriptors opened in the calling process at the time of the clone call.  Subsequent operations that open or close        file descriptors, or change file descriptor flags, performed by either the calling process or the child process do not affect the other process.  Note, however, that the duplicated file de‚Äê        scriptors in the child refer to the same open file descriptions as the corresponding file descriptors in the calling process, and  thus  share  file  offsets  and  file  status  flags  (see        <a href="./open.html">open(2)</a>).</p><p>CLONE_FS (since Linux 2.0)        If  CLONE_FS  is  set,  the caller and the child process share the same filesystem information.  This includes the root of the filesystem, the current working directory, and the umask.  Any        call to <a href="./chroot.html">chroot(2)</a>, <a href="./chdir.html">chdir(2)</a>, or <a href="./umask.html">umask(2)</a> performed by the calling process or the child process also affects the other process.</p><p>If CLONE_FS is not set, the child process works on a copy of the filesystem information of the calling process at the time of the clone call.  Calls to <a href="./chroot.html">chroot(2)</a>, <a href="./chdir.html">chdir(2)</a>, or <a href="./umask.html">umask(2)</a> per‚Äê        formed later by one of the processes do not affect the other process.</p><p>CLONE_INTO_CGROUP (since Linux 5.7)        By default, a child process is placed in the same version 2 cgroup as its parent.  The CLONE_INTO_CGROUP flag allows the child process to be created in a different version 2 cgroup.   (Note        that CLONE_INTO_CGROUP has effect only for version 2 cgroups.)</p><p>In  order  to  place  the  child process in a different cgroup, the caller specifies CLONE_INTO_CGROUP in cl_args.flags and passes a file descriptor that refers to a version 2 cgroup in the        cl_args.cgroup field.  (This file descriptor can be obtained by opening a cgroup v2 directory using either the O_RDONLY or the O_PATH flag.)  Note that all of the  usual  restrictions  (de‚Äê        scribed in <a href="./cgroups.html">cgroups(7)</a>) on placing a process into a version 2 cgroup apply.</p><p>Among the possible use cases for CLONE_INTO_CGROUP are the following: `</p><p>‚Ä¢  Spawning  a  process  into a cgroup different from the parent's cgroup makes it possible for a service manager to directly spawn new services into dedicated cgroups.  This eliminates the                  accounting jitter that would be caused if the child process was first created in the same cgroup as the parent and then moved into the target cgroup.   Furthermore,  spawning  the  child                  process directly into a target cgroup is significantly cheaper than moving the child process into the target cgroup after it has been created.</p><p>‚Ä¢  The CLONE_INTO_CGROUP flag also allows the creation of frozen child processes by spawning them into a frozen cgroup.  (See <a href="./cgroups.html">cgroups(7)</a> for a description of the freezer controller.)</p><p>‚Ä¢  For  threaded  applications (or even thread implementations which make use of cgroups to limit individual threads), it is possible to establish a fixed cgroup layout before spawning each                  thread directly into its target cgroup.</p><p>` CLONE_IO (since Linux 2.6.25)        If CLONE_IO is set, then the new process shares an I/O context with the calling process.  If this flag is not set, then (as with <a href="./fork.html">fork(2)</a>) the new process has its own I/O context.</p><p>The I/O context is the I/O scope of the disk scheduler (i.e., what the I/O scheduler uses to model scheduling of a process's I/O).  If processes share the same I/O context, they are treated        as one by the I/O scheduler.  As a consequence, they get to share disk time.  For some I/O schedulers, if two processes share an I/O context, they will be allowed to interleave  their  disk        access.  If several threads are doing I/O on behalf of the same process (<a href="./aio_read.html">aio_read(3)</a>, for instance), they should employ CLONE_IO to get better I/O performance.</p><p>If the kernel is not configured with the CONFIG_BLOCK option, this flag is a no-op.</p><p>CLONE_NEWCGROUP (since Linux 4.6)        Create the process in a new cgroup namespace.  If this flag is not set, then (as with <a href="./fork.html">fork(2)</a>) the process is created in the same cgroup namespaces as the calling process.</p><p>For further information on cgroup namespaces, see <a href="./cgroup_namespaces.html">cgroup_namespaces(7)</a>.</p><p>Only a privileged process (CAP_SYS_ADMIN) can employ CLONE_NEWCGROUP.</p><p>CLONE_NEWIPC (since Linux 2.6.19)        If  CLONE_NEWIPC  is  set,  then create the process in a new IPC namespace.  If this flag is not set, then (as with <a href="./fork.html">fork(2)</a>), the process is created in the same IPC namespace as the calling        process.</p><p>For further information on IPC namespaces, see <a href="./ipc_namespaces.html">ipc_namespaces(7)</a>.</p><p>Only a privileged process (CAP_SYS_ADMIN) can employ CLONE_NEWIPC.  This flag can't be specified in conjunction with CLONE_SYSVSEM.</p><p>CLONE_NEWNET (since Linux 2.6.24)        (The implementation of this flag was completed only by about Linux 2.6.29.)</p><p>If CLONE_NEWNET is set, then create the process in a new network namespace.  If this flag is not set, then (as with <a href="./fork.html">fork(2)</a>) the process is created in the  same  network  namespace  as  the        calling process.</p><p>For further information on network namespaces, see <a href="./network_namespaces.html">network_namespaces(7)</a>.</p><p>Only a privileged process (CAP_SYS_ADMIN) can employ CLONE_NEWNET.</p><p>CLONE_NEWNS (since Linux 2.4.19)        If  CLONE_NEWNS is set, the cloned child is started in a new mount namespace, initialized with a copy of the namespace of the parent.  If CLONE_NEWNS is not set, the child lives in the same        mount namespace as the parent.</p><p>For further information on mount namespaces, see <a href="./namespaces.html">namespaces(7)</a> and <a href="./mount_namespaces.html">mount_namespaces(7)</a>.</p><p>Only a privileged process (CAP_SYS_ADMIN) can employ CLONE_NEWNS.  It is not permitted to specify both CLONE_NEWNS and CLONE_FS in the same clone call.</p><p>CLONE_NEWPID (since Linux 2.6.24)        If CLONE_NEWPID is set, then create the process in a new PID namespace.  If this flag is not set, then (as with <a href="./fork.html">fork(2)</a>) the process is created in the same  PID  namespace  as  the  calling        process.</p><p>For further information on PID namespaces, see <a href="./namespaces.html">namespaces(7)</a> and <a href="./pid_namespaces.html">pid_namespaces(7)</a>.</p><p>Only a privileged process (CAP_SYS_ADMIN) can employ CLONE_NEWPID.  This flag can't be specified in conjunction with CLONE_THREAD.</p><p>CLONE_NEWUSER        (This  flag  first  became meaningful for clone() in Linux 2.6.23, the current clone() semantics were merged in Linux 3.5, and the final pieces to make the user namespaces completely usable        were merged in Linux 3.8.)</p><p>If CLONE_NEWUSER is set, then create the process in a new user namespace.  If this flag is not set, then (as with <a href="./fork.html">fork(2)</a>) the process is created in the same user namespace as  the  calling        process.</p><p>For further information on user namespaces, see <a href="./namespaces.html">namespaces(7)</a> and <a href="./user_namespaces.html">user_namespaces(7)</a>.</p><p>Before  Linux  3.8,  use  of CLONE_NEWUSER required that the caller have three capabilities: CAP_SYS_ADMIN, CAP_SETUID, and CAP_SETGID.  Starting with Linux 3.8, no privileges are needed to        create a user namespace.</p><p>This flag can't be specified in conjunction with CLONE_THREAD or CLONE_PARENT.  For security reasons, CLONE_NEWUSER cannot be specified in conjunction with CLONE_FS.</p><p>CLONE_NEWUTS (since Linux 2.6.19)        If CLONE_NEWUTS is set, then create the process in a new UTS namespace, whose identifiers are initialized by duplicating the identifiers from the UTS namespace of the calling  process.   If        this flag is not set, then (as with <a href="./fork.html">fork(2)</a>) the process is created in the same UTS namespace as the calling process.</p><p>For further information on UTS namespaces, see <a href="./uts_namespaces.html">uts_namespaces(7)</a>.</p><p>Only a privileged process (CAP_SYS_ADMIN) can employ CLONE_NEWUTS.</p><p>CLONE_PARENT (since Linux 2.3.12)        If CLONE_PARENT is set, then the parent of the new child (as returned by <a href="./getppid.html">getppid(2)</a>) will be the same as that of the calling process.</p><p>If CLONE_PARENT is not set, then (as with <a href="./fork.html">fork(2)</a>) the child's parent is the calling process.</p><p>Note  that  it  is the parent process, as returned by <a href="./getppid.html">getppid(2)</a>, which is signaled when the child terminates, so that if CLONE_PARENT is set, then the parent of the calling process, rather        than the calling process itself, is signaled.</p><p>The CLONE_PARENT flag can't be used in clone calls by the global init process (PID 1 in the initial PID namespace) and init processes in other PID namespaces.  This restriction prevents the        creation of multi-rooted process trees as well as the creation of unreapable zombies in the initial PID namespace.</p><p>CLONE_PARENT_SETTID (since Linux 2.5.49)        Store the child thread ID at the location pointed to by parent_tid (clone()) or cl_args.parent_tid (clone3()) in the parent's memory.  (In Linux 2.5.32-2.5.48 there was a flag  CLONE_SETTID        that did this.)  The store operation completes before the clone call returns control to user space.</p><p>CLONE_PID (Linux 2.0 to Linux 2.5.15)        If  CLONE_PID  is  set, the child process is created with the same process ID as the calling process.  This is good for hacking the system, but otherwise of not much use.  From Linux 2.3.21        onward, this flag could be specified only by the system boot process (PID 0).  The flag disappeared completely from the kernel sources in Linux 2.5.16.  Subsequently,  the  kernel  silently        ignored this bit if it was specified in the flags mask.  Much later, the same bit was recycled for use as the CLONE_PIDFD flag.</p><p>CLONE_PIDFD (since Linux 5.2)        If  this  flag  is  specified, a PID file descriptor referring to the child process is allocated and placed at a specified location in the parent's memory.  The close-on-exec flag is set on        this new file descriptor.  PID file descriptors can be used for the purposes described in <a href="./pidfd_open.html">pidfd_open(2)</a>. `</p><p>‚Ä¢  When using clone3(), the PID file descriptor is placed at the location pointed to by cl_args.pidfd.</p><p>‚Ä¢  When using clone(), the PID file descriptor is placed at the location pointed to by parent_tid.  Since the parent_tid argument is used to return the PID file descriptor, CLONE_PIDFD can‚Äê                  not be used with CLONE_PARENT_SETTID when calling clone().</p><p>` It is currently not possible to use this flag together with CLONE_THREAD.  This means that the process identified by the PID file descriptor will always be a thread group leader.</p><p>If the obsolete CLONE_DETACHED flag is specified alongside CLONE_PIDFD when calling clone(), an error is returned.  An error  also  results  if  CLONE_DETACHED  is  specified  when  calling clone3().  This error behavior ensures that the bit corresponding to CLONE_DETACHED can be reused for further PID file descriptor features in the future.</p><p>`</p><p>` CLONE_PTRACE (since Linux 2.2)        If CLONE_PTRACE is specified, and the calling process is being traced, then trace the child also (see <a href="./ptrace.html">ptrace(2)</a>).</p><p>CLONE_SETTLS (since Linux 2.5.32)        The TLS (Thread Local Storage) descriptor is set to tls.</p><p>The interpretation of tls and the resulting effect is architecture dependent.  On x86, tls is interpreted as a struct user_desc * (see <a href="./set_thread_area.html">set_thread_area(2)</a>).  On x86-64 it is the new value to        be set for the %fs base register (see the ARCH_SET_FS argument to <a href="./arch_prctl.html">arch_prctl(2)</a>).  On architectures with a dedicated TLS register, it is the new value of that register.</p><p>Use of this flag requires detailed knowledge and generally it should not be used except in libraries implementing threading.</p><p>CLONE_SIGHAND (since Linux 2.0)        If  CLONE_SIGHAND is set, the calling process and the child process share the same table of signal handlers.  If the calling process or child process calls <a href="./sigaction.html">sigaction(2)</a> to change the behav‚Äê        ior associated with a signal, the behavior is changed in the other process as well.  However, the calling process and child processes still have distinct signal masks and  sets  of  pending        signals.  So, one of them may block or unblock signals using <a href="./sigprocmask.html">sigprocmask(2)</a> without affecting the other process.</p><p>If  CLONE_SIGHAND is not set, the child process inherits a copy of the signal handlers of the calling process at the time of the clone call.  Calls to <a href="./sigaction.html">sigaction(2)</a> performed later by one of        the processes have no effect on the other process.</p><p>Since Linux 2.6.0, the flags mask must also include CLONE_VM if CLONE_SIGHAND is specified.</p><p>CLONE_STOPPED (since Linux 2.6.0)        If CLONE_STOPPED is set, then the child is initially stopped (as though it was sent a SIGSTOP signal), and must be resumed by sending it a SIGCONT signal.</p><p>This flag was deprecated from Linux 2.6.25 onward, and was removed altogether in Linux 2.6.38.  Since then, the kernel silently ignores it without error.  Starting with Linux 4.6, the  same        bit was reused for the CLONE_NEWCGROUP flag.</p><p>CLONE_SYSVSEM (since Linux 2.5.10)        If  CLONE_SYSVSEM  is set, then the child and the calling process share a single list of System V semaphore adjustment (semadj) values (see <a href="./semop.html">semop(2)</a>).  In this case, the shared list accumu‚Äê        lates semadj values across all processes sharing the list, and semaphore adjustments are performed only when the last process that is sharing the list terminates (or ceases sharing the list        using <a href="./unshare.html">unshare(2)</a>).  If this flag is not set, then the child has a separate semadj list that is initially empty.</p><p>CLONE_THREAD (since Linux 2.4.0)        If CLONE_THREAD is set, the child is placed in the same thread group as the calling process.  To make the remainder of the discussion of CLONE_THREAD more readable,  the  term  "thread"  is        used to refer to the processes within a thread group.</p><p>Thread  groups  were a feature added in Linux 2.4 to support the POSIX threads notion of a set of threads that share a single PID.  Internally, this shared PID is the so-called thread group        identifier (TGID) for the thread group.  Since Linux 2.4, calls to <a href="./getpid.html">getpid(2)</a> return the TGID of the caller.</p><p>The threads within a group can be distinguished by their (system-wide) unique thread IDs (TID).  A new thread's TID is available as the function result returned to the caller, and a  thread        can obtain its own TID using <a href="./gettid.html">gettid(2)</a>.</p><p>When  a  clone call is made without specifying CLONE_THREAD, then the resulting thread is placed in a new thread group whose TGID is the same as the thread's TID.  This thread is the leader        of the new thread group.</p><p>A new thread created with CLONE_THREAD has the same parent process as the process that made the clone call (i.e., like CLONE_PARENT), so that calls to <a href="./getppid.html">getppid(2)</a> return the same  value  for        all  of  the  threads in a thread group.  When a CLONE_THREAD thread terminates, the thread that created it is not sent a SIGCHLD (or other termination) signal; nor can the status of such a        thread be obtained using <a href="./wait.html">wait(2)</a>.  (The thread is said to be detached.)</p><p>After all of the threads in a thread group terminate the parent process of the thread group is sent a SIGCHLD (or other termination) signal.</p><p>If any of the threads in a thread group performs an <a href="./execve.html">execve(2)</a>, then all threads other than the thread group leader are terminated, and the new  program  is  executed  in  the  thread  group        leader.</p><p>If one of the threads in a thread group creates a child using <a href="./fork.html">fork(2)</a>, then any thread in the group can <a href="./wait.html">wait(2)</a> for that child.</p><p>Since Linux 2.5.35, the flags mask must also include CLONE_SIGHAND if CLONE_THREAD is specified (and note that, since Linux 2.6.0, CLONE_SIGHAND also requires CLONE_VM to be included).</p><p>Signal  dispositions  and actions are process-wide: if an unhandled signal is delivered to a thread, then it will affect (terminate, stop, continue, be ignored in) all members of the thread        group.</p><p>Each thread has its own signal mask, as set by <a href="./sigprocmask.html">sigprocmask(2)</a>.</p><p>A signal may be process-directed or thread-directed.  A process-directed signal is targeted at a thread group (i.e., a TGID), and is delivered to an arbitrarily selected thread  from  among        those  that  are  not blocking the signal.  A signal may be process-directed because it was generated by the kernel for reasons other than a hardware exception, or because it was sent using        <a href="./kill.html">kill(2)</a> or <a href="./sigqueue.html">sigqueue(3)</a>.  A thread-directed signal is targeted at (i.e., delivered to) a specific thread.   A  signal  may  be  thread  directed  because  it  was  sent  using  <a href="./tgkill.html">tgkill(2)</a>  or        <a href="./pthread_sigqueue.html">pthread_sigqueue(3)</a>,  or  because  the thread executed a machine language instruction that triggered a hardware exception (e.g., invalid memory access triggering SIGSEGV or a floating-point        exception triggering SIGFPE).</p><p>A call to <a href="./sigpending.html">sigpending(2)</a> returns a signal set that is the union of the pending process-directed signals and the signals that are pending for the calling thread.</p><p>If a process-directed signal is delivered to a thread group, and the thread group has installed a handler for the signal, then the handler is invoked in exactly  one,  arbitrarily  selected        member  of  the  thread group that has not blocked the signal.  If multiple threads in a group are waiting to accept the same signal using <a href="./sigwaitinfo.html">sigwaitinfo(2)</a>, the kernel will arbitrarily select        one of these threads to receive the signal.</p><p>CLONE_UNTRACED (since Linux 2.5.46)        If CLONE_UNTRACED is specified, then a tracing process cannot force CLONE_PTRACE on this child process.</p><p>CLONE_VFORK (since Linux 2.2)        If CLONE_VFORK is set, the execution of the calling process is suspended until the child releases its virtual memory resources via a call to <a href="./execve.html">execve(2)</a> or _exit(2) (as with <a href="./vfork.html">vfork(2)</a>).</p><p>If CLONE_VFORK is not set, then both the calling process and the child are schedulable after the call, and an application should not rely on execution occurring in any particular order.</p><p>CLONE_VM (since Linux 2.0)        If CLONE_VM is set, the calling process and the child process run in the same memory space.  In particular, memory writes performed by the calling process or by the child process  are  also        visible in the other process.  Moreover, any memory mapping or unmapping performed with <a href="./mmap.html">mmap(2)</a> or <a href="./munmap.html">munmap(2)</a> by the child or calling process also affects the other process.</p><p>If  CLONE_VM  is not set, the child process runs in a separate copy of the memory space of the calling process at the time of the clone call.  Memory writes or file mappings/unmappings per‚Äê        formed by one of the processes do not affect the other, as with <a href="./fork.html">fork(2)</a>.</p><p>If the CLONE_VM flag is specified and the CLONE_VFORK flag is not specified, then any alternate signal stack that was established by <a href="./sigaltstack.html">sigaltstack(2)</a> is cleared in the child process. `</p><h3 id="return-value">Return Value</h3><pre><code>On success, the thread ID of the child process is returned in the caller's thread of execution.  On failure, -1 is returned in the caller's context, no child process is created, and errno  is  set
to indicate the error.
</code></pre><h3 id="errors">Errors</h3><p>` EACCES (clone3() only)        CLONE_INTO_CGROUP was specified in cl_args.flags, but the restrictions (described in <a href="./cgroups.html">cgroups(7)</a>) on placing the child process into the version 2 cgroup referred to by cl_args.cgroup are not        met.</p><p>EAGAIN Too many processes are already running; see <a href="./fork.html">fork(2)</a>.</p><p>EBUSY (clone3() only)        CLONE_INTO_CGROUP was specified in cl_args.flags, but the file descriptor specified in cl_args.cgroup refers to a version 2 cgroup in which a domain controller is enabled.</p><p>EEXIST (clone3() only)        One (or more) of the PIDs specified in set_tid already exists in the corresponding PID namespace.</p><p>EINVAL Both CLONE_SIGHAND and CLONE_CLEAR_SIGHAND were specified in the flags mask.</p><p>EINVAL CLONE_SIGHAND was specified in the flags mask, but CLONE_VM was not.  (Since Linux 2.6.0.)</p><p>EINVAL CLONE_THREAD was specified in the flags mask, but CLONE_SIGHAND was not.  (Since Linux 2.5.35.)</p><p>EINVAL CLONE_THREAD was specified in the flags mask, but the current process previously called <a href="./unshare.html">unshare(2)</a> with the CLONE_NEWPID flag or used <a href="./setns.html">setns(2)</a> to reassociate itself with a PID namespace.</p><p>EINVAL Both CLONE_FS and CLONE_NEWNS were specified in the flags mask.</p><p>EINVAL (since Linux 3.9)        Both CLONE_NEWUSER and CLONE_FS were specified in the flags mask.</p><p>EINVAL Both CLONE_NEWIPC and CLONE_SYSVSEM were specified in the flags mask.</p><p>EINVAL CLONE_NEWPID and one (or both) of CLONE_THREAD or CLONE_PARENT were specified in the flags mask.</p><p>EINVAL CLONE_NEWUSER and CLONE_THREAD were specified in the flags mask.</p><p>EINVAL (since Linux 2.6.32)        CLONE_PARENT was specified, and the caller is an init process.</p><p>EINVAL Returned by the glibc clone() wrapper function when fn or stack is specified as NULL.</p><p>EINVAL CLONE_NEWIPC was specified in the flags mask, but the kernel was not configured with the CONFIG_SYSVIPC and CONFIG_IPC_NS options.</p><p>EINVAL CLONE_NEWNET was specified in the flags mask, but the kernel was not configured with the CONFIG_NET_NS option.</p><p>EINVAL CLONE_NEWPID was specified in the flags mask, but the kernel was not configured with the CONFIG_PID_NS option.</p><p>EINVAL CLONE_NEWUSER was specified in the flags mask, but the kernel was not configured with the CONFIG_USER_NS option.</p><p>EINVAL CLONE_NEWUTS was specified in the flags mask, but the kernel was not configured with the CONFIG_UTS_NS option.</p><p>EINVAL stack is not aligned to a suitable boundary for this architecture.  For example, on aarch64, stack must be a multiple of 16.</p><p>EINVAL (clone3() only)        CLONE_DETACHED was specified in the flags mask.</p><p>EINVAL (clone() only)        CLONE_PIDFD was specified together with CLONE_DETACHED in the flags mask.</p><p>EINVAL CLONE_PIDFD was specified together with CLONE_THREAD in the flags mask.</p><p>EINVAL (clone() only)        CLONE_PIDFD was specified together with CLONE_PARENT_SETTID in the flags mask.</p><p>EINVAL (clone3() only)        set_tid_size is greater than the number of nested PID namespaces.</p><p>EINVAL (clone3() only)        One of the PIDs specified in set_tid was an invalid.</p><p>EINVAL (clone3() only)        CLONE_THREAD or CLONE_PARENT was specified in the flags mask, but a signal was specified in exit_signal.</p><p>EINVAL (AArch64 only, Linux 4.6 and earlier)        stack was not aligned to a 128-bit boundary.</p><p>ENOMEM Cannot allocate sufficient memory to allocate a task structure for the child, or to copy those parts of the caller's context that need to be copied.</p><p>ENOSPC (since Linux 3.7)        CLONE_NEWPID was specified in the flags mask, but the limit on the nesting depth of PID namespaces would have been exceeded; see <a href="./pid_namespaces.html">pid_namespaces(7)</a>.</p><p>ENOSPC (since Linux 4.9; beforehand EUSERS)        CLONE_NEWUSER was specified in the flags mask, and the call would cause the limit on the number of nested user namespaces to be exceeded.  See <a href="./user_namespaces.html">user_namespaces(7)</a>.</p><p>From Linux 3.11 to Linux 4.8, the error diagnosed in this case was EUSERS.</p><p>ENOSPC (since Linux 4.9)        One  of  the  values in the flags mask specified the creation of a new user namespace, but doing so would have caused the limit defined by the corresponding file in /proc/sys/user to be ex‚Äê        ceeded.  For further details, see <a href="./namespaces.html">namespaces(7)</a>.</p><p>EOPNOTSUPP (clone3() only)        CLONE_INTO_CGROUP was specified in cl_args.flags, but the file descriptor specified in cl_args.cgroup refers to a version 2 cgroup that is in the domain invalid state.</p><p>EPERM  CLONE_NEWCGROUP, CLONE_NEWIPC, CLONE_NEWNET, CLONE_NEWNS, CLONE_NEWPID, or CLONE_NEWUTS was specified by an unprivileged process (process without CAP_SYS_ADMIN).</p><p>EPERM  CLONE_PID was specified by a process other than process 0.  (This error occurs only on Linux 2.5.15 and earlier.)</p><p>EPERM  CLONE_NEWUSER was specified in the flags mask, but either the effective user ID or the effective group ID of the caller does not have a mapping  in  the  parent  namespace  (see  user_name‚Äê        <a href="./spaces.html">spaces(7)</a>).</p><p>EPERM (since Linux 3.9)        CLONE_NEWUSER  was specified in the flags mask and the caller is in a chroot environment (i.e., the caller's root directory does not match the root directory of the mount namespace in which        it resides).</p><p>EPERM (clone3() only)        set_tid_size was greater than zero, and the caller lacks the CAP_SYS_ADMIN capability in one or more of the user namespaces that own the corresponding PID namespaces.</p><p>ERESTARTNOINTR (since Linux 2.6.17)        System call was interrupted by a signal and will be restarted.  (This can be seen only during a trace.)</p><p>EUSERS (Linux 3.11 to Linux 4.8)        CLONE_NEWUSER was specified in the flags mask, and the limit on the number of nested user namespaces would be exceeded.  See the discussion of the ENOSPC error above. `</p><h3 id="versions">Versions</h3><p>` The glibc clone() wrapper function makes some changes in the memory pointed to by stack (changes required to set the stack up correctly for the child) before invoking the clone() system call.  So, in cases where clone() is used to recursively create children, do not use the buffer employed for the parent's stack as the stack of the child.</p><p>On i386, clone() should not be called through vsyscall, but directly through int $0x80. `</p><p>C library/kernel differences ` The raw clone() system call corresponds more closely to <a href="./fork.html">fork(2)</a> in that execution in the child continues from the point of the call.  As such, the fn and arg arguments of the clone() wrapper func‚Äê tion are omitted.</p><p>In contrast to the glibc wrapper, the raw clone() system call accepts NULL as a stack argument (and clone3() likewise allows cl_args.stack to be NULL).  In this case, the child uses a duplicate of the parent's stack.  (Copy-on-write semantics ensure that the child gets separate copies of stack pages when either process modifies the stack.)  In this case, for correct operation, the  CLONE_VM option should not be specified.  (If the child shares the parent's memory because of the use of the CLONE_VM flag, then no copy-on-write duplication occurs and chaos is likely to result.)</p><p>The order of the arguments also differs in the raw system call, and there are variations in the arguments across architectures, as detailed in the following paragraphs.</p><p>The raw system call interface on x86-64 and some other architectures (including sh, tile, and alpha) is:</p><p>long clone(unsigned long flags, void *stack,                int *parent_tid, int *child_tid,                unsigned long tls);</p><p>On x86-32, and several other common architectures (including score, ARM, ARM 64, PA-RISC, arc, Power PC, xtensa, and MIPS), the order of the last two arguments is reversed:</p><p>long clone(unsigned long flags, void *stack,               int *parent_tid, unsigned long tls,               int *child_tid);</p><p>On the cris and s390 architectures, the order of the first two arguments is reversed:</p><p>long clone(void *stack, unsigned long flags,                int *parent_tid, int *child_tid,                unsigned long tls);</p><p>On the microblaze architecture, an additional argument is supplied:</p><p>long clone(unsigned long flags, void *stack,                int stack_size,         /* Size of stack */                int *parent_tid, int *child_tid,                unsigned long tls); `</p><p>blackfin, m68k, and sparc <code> The argument-passing conventions on blackfin, m68k, and sparc are different from the descriptions above.  For details, see the kernel (and glibc) source. </code></p><p>ia64 ` On ia64, a different interface is used:</p><p>int __clone2(int (*fn)(void *),                  void *stack_base, size_t stack_size,                  int flags, void *arg, ...               /* pid_t *parent_tid, struct user_desc *tls,                  pid_t *child_tid */ );</p><p>The prototype shown above is for the glibc wrapper function; for the system call itself, the prototype can be described as follows (it is identical to the clone() prototype on microblaze):</p><p>long clone2(unsigned long flags, void *stack_base,                 int stack_size,         /* Size of stack */                 int *parent_tid, int *child_tid,                 unsigned long tls);</p><p>__clone2()  operates  in  the  same  way  as  clone(),  except  that stack_base points to the lowest address of the child's stack area, and stack_size specifies the size of the stack pointed to by stack_base. `</p><h3 id="standards">Standards</h3><pre><code>Linux.
</code></pre><h3 id="history">History</h3><pre><code>clone3()
       Linux 5.3.
</code></pre><p>Linux 2.4 and earlier ` In the Linux 2.4.x series, CLONE_THREAD generally does not make the parent of the new thread the same as the parent of the  calling  process.   However,  from  Linux  2.4.7  to  Linux  2.4.18  the CLONE_THREAD flag implied the CLONE_PARENT flag (as in Linux 2.6.0 and later).</p><p>In Linux 2.4 and earlier, clone() does not take arguments parent_tid, tls, and child_tid. `</p><h3 id="notes">Notes</h3><p>` One use of these system calls is to implement threads: multiple flows of control in a program that run concurrently in a shared address space.</p><p>The <a href="./kcmp.html">kcmp(2)</a> system call can be used to test whether two processes share various resources such as a file descriptor table, System V semaphore undo operations, or a virtual address space.</p><p>Handlers registered using <a href="./pthread_atfork.html">pthread_atfork(3)</a> are not executed during a clone call. `</p><h3 id="bugs">Bugs</h3><p>` GNU  C  library versions 2.3.4 up to and including 2.24 contained a wrapper function for <a href="./getpid.html">getpid(2)</a> that performed caching of PIDs.  This caching relied on support in the glibc wrapper for clone(), but limitations in the implementation meant that the cache was not up to date in some circumstances.  In particular, if a signal was delivered to the child immediately after the clone() call, then a call to <a href="./getpid.html">getpid(2)</a> in a handler for the signal could return the PID of the calling process ("the parent"), if the clone wrapper had not yet had a chance to update the  PID  cache  in  the  child. (This  discussion ignores the case where the child was created using CLONE_THREAD, when <a href="./getpid.html">getpid(2)</a> should return the same value in the child and in the process that called clone(), since the caller and the child are in the same thread group.  The stale-cache problem also does not occur if the flags argument includes CLONE_VM.)  To get the truth, it was sometimes necessary to use code such as the following:</p><p>#include <syscall.h></p><p>pid_t mypid;</p><p>mypid = syscall(SYS_getpid);</p><p>Because of the stale-cache problem, as well as other problems noted in <a href="./getpid.html">getpid(2)</a>, the PID caching feature was removed in glibc 2.25. `</p><h2 id="examples">Examples</h2><p>` The following program demonstrates the use of clone() to create a child process that executes in a separate UTS namespace.  The child changes the hostname in its UTS namespace.   Both  parent  and child then display the system hostname, making it possible to see that the hostname differs in the UTS namespaces of the parent and child.  For an example of the use of this program, see <a href="./setns.html">setns(2)</a>.</p><p>Within the sample program, we allocate the memory that is to be used for the child's stack using <a href="./mmap.html">mmap(2)</a> rather than <a href="./malloc.html">malloc(3)</a> for the following reasons: `</p><p>‚Ä¢  <a href="./mmap.html">mmap(2)</a> allocates a block of memory that starts on a page boundary and is a multiple of the page size.  This is useful if we want to establish a guard page (a page with protection PROT_NONE) at           the end of the stack using <a href="./mprotect.html">mprotect(2)</a>.</p><p>‚Ä¢  We  can  specify  the MAP_STACK flag to request a mapping that is suitable for a stack.  For the moment, this flag is a no-op on Linux, but it exists and has effect on some other systems, so we           should include it for portability.</p><p>Program source ` #define _GNU_SOURCE #include <err.h> #include <sched.h> #include <signal.h> #include <stdint.h> #include <stdio.h> #include <stdlib.h> #include <string.h> #include <sys/mman.h> #include <sys/utsname.h> #include <sys/wait.h> #include <unistd.h></p><p>static int              /* Start function for cloned child */ childFunc(void *arg) {     struct utsname uts;</p><p>/* Change hostname in UTS namespace of child. */</p><p>if (sethostname(arg, strlen(arg)) == -1)         err(EXIT_FAILURE, "sethostname");</p><p>/* Retrieve and display hostname. */</p><p>if (uname(&uts) == -1)         err(EXIT_FAILURE, "uname");     printf("uts.nodename in child:  %s\n", uts.nodename);</p><p>/* Keep the namespace open for a while, by sleeping.        This allows some experimentation--for example, another        process might join the namespace. */</p><p><a href="./sleep.html">sleep(200)</a>;</p><p>return 0;           /* Child terminates now */ }</p><p>#define STACK_SIZE (1024 * 1024)    /* Stack size for cloned child */</p><p>int main(int argc, char *argv[]) {     char            *stack;         /* Start of stack buffer */     char            *stackTop;      /* End of stack buffer */     pid_t           pid;     struct utsname  uts;</p><p>if (argc < 2) {         fprintf(stderr, "Usage: %s <child-hostname>\n", argv[0]);         exit(EXIT_SUCCESS);     }</p><p>/* Allocate memory to be used for the stack of the child. */</p><p>stack = mmap(NULL, STACK_SIZE, PROT_READ | PROT_WRITE,                  MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0);     if (stack == MAP_FAILED)         err(EXIT_FAILURE, "mmap");</p><p>stackTop = stack + STACK_SIZE;  /* Assume stack grows downward */</p><p>/* Create child that has its own UTS namespace;        child commences execution in childFunc(). */</p><p>pid = clone(childFunc, stackTop, CLONE_NEWUTS | SIGCHLD, argv[1]);     if (pid == -1)         err(EXIT_FAILURE, "clone");     printf("clone() returned %jd\n", (intmax_t) pid);</p><p>/* Parent falls through to here */</p><p><a href="./sleep.html">sleep(1)</a>;           /* Give child time to change its hostname */</p><p>/* Display hostname in parent's UTS namespace. This will be        different from hostname in child's UTS namespace. */</p><p>if (uname(&uts) == -1)         err(EXIT_FAILURE, "uname");     printf("uts.nodename in parent: %s\n", uts.nodename);</p><p>if (waitpid(pid, NULL, 0) == -1)    /* Wait for child */         err(EXIT_FAILURE, "waitpid");     printf("child has terminated\n");</p><p>exit(EXIT_SUCCESS); } `</p><h2 id="see-also">See Also</h2><pre><code>fork(2), futex(2), getpid(2), gettid(2), kcmp(2),  mmap(2),  pidfd_open(2),  set_thread_area(2),  set_tid_address(2),  setns(2),  tkill(2),  unshare(2),  wait(2),  capabilities(7),  namespaces(7),
pthreads(7)
</code></pre><p>Linux man-pages 6.7                                                                              2024-02-18                                                                                        [<a href="./clone.html">clone(2)</a>](clone.html)</p></div>
    </article>
</body>

</html>
